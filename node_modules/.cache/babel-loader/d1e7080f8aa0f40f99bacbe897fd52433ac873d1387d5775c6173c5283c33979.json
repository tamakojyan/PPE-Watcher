{"ast":null,"code":"import { base64Decode, base64Encode } from \"../encoding/base64.js\";\nimport { md5 } from \"../encoding/md5.js\";\nimport { LICENSE_STATUS } from \"../utils/licenseStatus.js\";\nimport { PLAN_SCOPES } from \"../utils/plan.js\";\nimport { LICENSE_MODELS } from \"../utils/licenseModel.js\";\nconst getDefaultReleaseDate = () => {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  return today;\n};\nexport function generateReleaseInfo(releaseDate = getDefaultReleaseDate()) {\n  return base64Encode(releaseDate.getTime().toString());\n}\nfunction isPlanScopeSufficient(packageName, planScope) {\n  let acceptedScopes;\n  if (packageName.includes('-pro')) {\n    acceptedScopes = ['pro', 'premium'];\n  } else if (packageName.includes('-premium')) {\n    acceptedScopes = ['premium'];\n  } else {\n    acceptedScopes = [];\n  }\n  return acceptedScopes.includes(planScope);\n}\nconst expiryReg = /^.*EXPIRY=([0-9]+),.*$/;\nconst orderReg = /^.*ORDER:([0-9]+),.*$/;\nconst PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN = ['x-data-grid-pro', 'x-date-pickers-pro'];\n\n/**\n * Format: ORDER:${orderNumber},EXPIRY=${expiryTimestamp},KEYVERSION=1\n */\nfunction decodeLicenseVersion1(license) {\n  let expiryTimestamp;\n  let orderId;\n  try {\n    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);\n    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {\n      expiryTimestamp = null;\n    }\n    orderId = parseInt(license.match(orderReg)[1], 10);\n    if (!orderId || Number.isNaN(orderId)) {\n      orderId = null;\n    }\n  } catch (err) {\n    expiryTimestamp = null;\n    orderId = null;\n  }\n  return {\n    version: 1,\n    licenseModel: 'perpetual',\n    planScope: 'pro',\n    planVersion: 'initial',\n    expiryTimestamp,\n    expiryDate: expiryTimestamp ? new Date(expiryTimestamp) : null,\n    orderId\n  };\n}\n\n/**\n * Format: O=${orderNumber},E=${expiryTimestamp},S=${planScope},LM=${licenseModel},PV=${planVersion},KV=2`;\n */\nfunction decodeLicenseVersion2(license) {\n  const licenseInfo = {\n    version: 2,\n    licenseModel: null,\n    planScope: null,\n    planVersion: 'initial',\n    expiryTimestamp: null,\n    expiryDate: null,\n    orderId: null\n  };\n  license.split(',').map(token => token.split('=')).filter(el => el.length === 2).forEach(([key, value]) => {\n    if (key === 'S') {\n      licenseInfo.planScope = value;\n    }\n    if (key === 'LM') {\n      licenseInfo.licenseModel = value;\n    }\n    if (key === 'E') {\n      const expiryTimestamp = parseInt(value, 10);\n      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {\n        licenseInfo.expiryTimestamp = expiryTimestamp;\n        licenseInfo.expiryDate = new Date(expiryTimestamp);\n      }\n    }\n    if (key === 'PV') {\n      licenseInfo.planVersion = value;\n    }\n    if (key === 'O') {\n      const orderNum = parseInt(value, 10);\n      if (orderNum && !Number.isNaN(orderNum)) {\n        licenseInfo.orderId = orderNum;\n      }\n    }\n  });\n  return licenseInfo;\n}\n\n/**\n * Decode the license based on its key version and return a version-agnostic `MuiLicense` object.\n */\nfunction decodeLicense(encodedLicense) {\n  const license = base64Decode(encodedLicense);\n  if (license.includes('KEYVERSION=1')) {\n    return decodeLicenseVersion1(license);\n  }\n  if (license.includes('KV=2')) {\n    return decodeLicenseVersion2(license);\n  }\n  return null;\n}\nexport function verifyLicense({\n  releaseInfo,\n  licenseKey,\n  packageName\n}) {\n  // Gets replaced at build time\n  // @ts-ignore\n  if (false) {\n    return {\n      status: LICENSE_STATUS.Valid\n    };\n  }\n  if (!releaseInfo) {\n    throw new Error('MUI X: The release information is missing. Not able to validate license.');\n  }\n  if (!licenseKey) {\n    return {\n      status: LICENSE_STATUS.NotFound\n    };\n  }\n  const hash = licenseKey.substr(0, 32);\n  const encoded = licenseKey.substr(32);\n  if (hash !== md5(encoded)) {\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  const license = decodeLicense(encoded);\n  if (license == null) {\n    console.error('MUI X: Error checking license. Key version not found!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.licenseModel == null || !LICENSE_MODELS.includes(license.licenseModel)) {\n    console.error('MUI X: Error checking license. License model not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.expiryTimestamp == null) {\n    console.error('MUI X: Error checking license. Expiry timestamp not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.licenseModel === 'perpetual' || process.env.NODE_ENV === 'production') {\n    const pkgTimestamp = parseInt(base64Decode(releaseInfo), 10);\n    if (Number.isNaN(pkgTimestamp)) {\n      throw new Error('MUI X: The release information is invalid. Not able to validate license.');\n    }\n    if (license.expiryTimestamp < pkgTimestamp) {\n      return {\n        status: LICENSE_STATUS.ExpiredVersion\n      };\n    }\n  } else if (license.licenseModel === 'subscription' || license.licenseModel === 'annual') {\n    if (new Date().getTime() > license.expiryTimestamp) {\n      if (\n      // 30 days grace\n      new Date().getTime() < license.expiryTimestamp + 1000 * 3600 * 24 * 30 || process.env.NODE_ENV !== 'development') {\n        return {\n          status: LICENSE_STATUS.ExpiredAnnualGrace,\n          meta: {\n            expiryTimestamp: license.expiryTimestamp,\n            licenseKey\n          }\n        };\n      }\n      return {\n        status: LICENSE_STATUS.ExpiredAnnual,\n        meta: {\n          expiryTimestamp: license.expiryTimestamp,\n          licenseKey\n        }\n      };\n    }\n  }\n  if (license.planScope == null || !PLAN_SCOPES.includes(license.planScope)) {\n    console.error('MUI X: Error checking license. planScope not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (!isPlanScopeSufficient(packageName, license.planScope)) {\n    return {\n      status: LICENSE_STATUS.OutOfScope\n    };\n  }\n\n  // 'charts-pro' or 'tree-view-pro' can only be used with a newer Pro license\n  if (license.planVersion === 'initial' && license.planScope === 'pro' && !PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN.includes(packageName)) {\n    return {\n      status: LICENSE_STATUS.NotAvailableInInitialProPlan\n    };\n  }\n  return {\n    status: LICENSE_STATUS.Valid\n  };\n}","map":{"version":3,"names":["base64Decode","base64Encode","md5","LICENSE_STATUS","PLAN_SCOPES","LICENSE_MODELS","getDefaultReleaseDate","today","Date","setHours","generateReleaseInfo","releaseDate","getTime","toString","isPlanScopeSufficient","packageName","planScope","acceptedScopes","includes","expiryReg","orderReg","PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN","decodeLicenseVersion1","license","expiryTimestamp","orderId","parseInt","match","Number","isNaN","err","version","licenseModel","planVersion","expiryDate","decodeLicenseVersion2","licenseInfo","split","map","token","filter","el","length","forEach","key","value","orderNum","decodeLicense","encodedLicense","verifyLicense","releaseInfo","licenseKey","status","Valid","Error","NotFound","hash","substr","encoded","Invalid","console","error","process","env","NODE_ENV","pkgTimestamp","ExpiredVersion","ExpiredAnnualGrace","meta","ExpiredAnnual","OutOfScope","NotAvailableInInitialProPlan"],"sources":["C:/Users/tamak/Desktop/Workspace/ppe-watcher/node_modules/@mui/x-license/esm/verifyLicense/verifyLicense.js"],"sourcesContent":["import { base64Decode, base64Encode } from \"../encoding/base64.js\";\nimport { md5 } from \"../encoding/md5.js\";\nimport { LICENSE_STATUS } from \"../utils/licenseStatus.js\";\nimport { PLAN_SCOPES } from \"../utils/plan.js\";\nimport { LICENSE_MODELS } from \"../utils/licenseModel.js\";\nconst getDefaultReleaseDate = () => {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  return today;\n};\nexport function generateReleaseInfo(releaseDate = getDefaultReleaseDate()) {\n  return base64Encode(releaseDate.getTime().toString());\n}\nfunction isPlanScopeSufficient(packageName, planScope) {\n  let acceptedScopes;\n  if (packageName.includes('-pro')) {\n    acceptedScopes = ['pro', 'premium'];\n  } else if (packageName.includes('-premium')) {\n    acceptedScopes = ['premium'];\n  } else {\n    acceptedScopes = [];\n  }\n  return acceptedScopes.includes(planScope);\n}\nconst expiryReg = /^.*EXPIRY=([0-9]+),.*$/;\nconst orderReg = /^.*ORDER:([0-9]+),.*$/;\nconst PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN = ['x-data-grid-pro', 'x-date-pickers-pro'];\n\n/**\n * Format: ORDER:${orderNumber},EXPIRY=${expiryTimestamp},KEYVERSION=1\n */\nfunction decodeLicenseVersion1(license) {\n  let expiryTimestamp;\n  let orderId;\n  try {\n    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);\n    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {\n      expiryTimestamp = null;\n    }\n    orderId = parseInt(license.match(orderReg)[1], 10);\n    if (!orderId || Number.isNaN(orderId)) {\n      orderId = null;\n    }\n  } catch (err) {\n    expiryTimestamp = null;\n    orderId = null;\n  }\n  return {\n    version: 1,\n    licenseModel: 'perpetual',\n    planScope: 'pro',\n    planVersion: 'initial',\n    expiryTimestamp,\n    expiryDate: expiryTimestamp ? new Date(expiryTimestamp) : null,\n    orderId\n  };\n}\n\n/**\n * Format: O=${orderNumber},E=${expiryTimestamp},S=${planScope},LM=${licenseModel},PV=${planVersion},KV=2`;\n */\nfunction decodeLicenseVersion2(license) {\n  const licenseInfo = {\n    version: 2,\n    licenseModel: null,\n    planScope: null,\n    planVersion: 'initial',\n    expiryTimestamp: null,\n    expiryDate: null,\n    orderId: null\n  };\n  license.split(',').map(token => token.split('=')).filter(el => el.length === 2).forEach(([key, value]) => {\n    if (key === 'S') {\n      licenseInfo.planScope = value;\n    }\n    if (key === 'LM') {\n      licenseInfo.licenseModel = value;\n    }\n    if (key === 'E') {\n      const expiryTimestamp = parseInt(value, 10);\n      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {\n        licenseInfo.expiryTimestamp = expiryTimestamp;\n        licenseInfo.expiryDate = new Date(expiryTimestamp);\n      }\n    }\n    if (key === 'PV') {\n      licenseInfo.planVersion = value;\n    }\n    if (key === 'O') {\n      const orderNum = parseInt(value, 10);\n      if (orderNum && !Number.isNaN(orderNum)) {\n        licenseInfo.orderId = orderNum;\n      }\n    }\n  });\n  return licenseInfo;\n}\n\n/**\n * Decode the license based on its key version and return a version-agnostic `MuiLicense` object.\n */\nfunction decodeLicense(encodedLicense) {\n  const license = base64Decode(encodedLicense);\n  if (license.includes('KEYVERSION=1')) {\n    return decodeLicenseVersion1(license);\n  }\n  if (license.includes('KV=2')) {\n    return decodeLicenseVersion2(license);\n  }\n  return null;\n}\nexport function verifyLicense({\n  releaseInfo,\n  licenseKey,\n  packageName\n}) {\n  // Gets replaced at build time\n  // @ts-ignore\n  if (false) {\n    return {\n      status: LICENSE_STATUS.Valid\n    };\n  }\n  if (!releaseInfo) {\n    throw new Error('MUI X: The release information is missing. Not able to validate license.');\n  }\n  if (!licenseKey) {\n    return {\n      status: LICENSE_STATUS.NotFound\n    };\n  }\n  const hash = licenseKey.substr(0, 32);\n  const encoded = licenseKey.substr(32);\n  if (hash !== md5(encoded)) {\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  const license = decodeLicense(encoded);\n  if (license == null) {\n    console.error('MUI X: Error checking license. Key version not found!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.licenseModel == null || !LICENSE_MODELS.includes(license.licenseModel)) {\n    console.error('MUI X: Error checking license. License model not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.expiryTimestamp == null) {\n    console.error('MUI X: Error checking license. Expiry timestamp not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.licenseModel === 'perpetual' || process.env.NODE_ENV === 'production') {\n    const pkgTimestamp = parseInt(base64Decode(releaseInfo), 10);\n    if (Number.isNaN(pkgTimestamp)) {\n      throw new Error('MUI X: The release information is invalid. Not able to validate license.');\n    }\n    if (license.expiryTimestamp < pkgTimestamp) {\n      return {\n        status: LICENSE_STATUS.ExpiredVersion\n      };\n    }\n  } else if (license.licenseModel === 'subscription' || license.licenseModel === 'annual') {\n    if (new Date().getTime() > license.expiryTimestamp) {\n      if (\n      // 30 days grace\n      new Date().getTime() < license.expiryTimestamp + 1000 * 3600 * 24 * 30 || process.env.NODE_ENV !== 'development') {\n        return {\n          status: LICENSE_STATUS.ExpiredAnnualGrace,\n          meta: {\n            expiryTimestamp: license.expiryTimestamp,\n            licenseKey\n          }\n        };\n      }\n      return {\n        status: LICENSE_STATUS.ExpiredAnnual,\n        meta: {\n          expiryTimestamp: license.expiryTimestamp,\n          licenseKey\n        }\n      };\n    }\n  }\n  if (license.planScope == null || !PLAN_SCOPES.includes(license.planScope)) {\n    console.error('MUI X: Error checking license. planScope not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (!isPlanScopeSufficient(packageName, license.planScope)) {\n    return {\n      status: LICENSE_STATUS.OutOfScope\n    };\n  }\n\n  // 'charts-pro' or 'tree-view-pro' can only be used with a newer Pro license\n  if (license.planVersion === 'initial' && license.planScope === 'pro' && !PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN.includes(packageName)) {\n    return {\n      status: LICENSE_STATUS.NotAvailableInInitialProPlan\n    };\n  }\n  return {\n    status: LICENSE_STATUS.Valid\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}