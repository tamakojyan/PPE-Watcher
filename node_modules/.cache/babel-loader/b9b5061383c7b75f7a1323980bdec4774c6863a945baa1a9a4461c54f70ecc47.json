{"ast":null,"code":"import { mergeDateAndTime } from '@mui/x-date-pickers/internals';\nexport function resolveReferenceDate(referenceDate, rangePosition) {\n  if (Array.isArray(referenceDate)) {\n    return rangePosition === 'start' ? referenceDate[0] : referenceDate[1];\n  }\n  return referenceDate;\n}\nexport function calculateRangeChange({\n  adapter,\n  range,\n  newDate: selectedDate,\n  rangePosition,\n  allowRangeFlip = false,\n  shouldMergeDateAndTime = false,\n  referenceDate\n}) {\n  const start = !adapter.isValid(range[0]) ? null : range[0];\n  const end = !adapter.isValid(range[1]) ? null : range[1];\n  if (shouldMergeDateAndTime && selectedDate) {\n    // If there is a date already selected, then we want to keep its time\n    if (start && rangePosition === 'start') {\n      selectedDate = mergeDateAndTime(adapter, selectedDate, start);\n    }\n    if (end && rangePosition === 'end') {\n      selectedDate = mergeDateAndTime(adapter, selectedDate, end);\n    }\n  }\n  const newSelectedDate = referenceDate && selectedDate && shouldMergeDateAndTime ? mergeDateAndTime(adapter, selectedDate, resolveReferenceDate(referenceDate, rangePosition)) : selectedDate;\n  if (rangePosition === 'start') {\n    const truthyResult = allowRangeFlip ? {\n      nextSelection: 'start',\n      newRange: [end, newSelectedDate]\n    } : {\n      nextSelection: 'end',\n      newRange: [newSelectedDate, null]\n    };\n    return Boolean(end) && adapter.isAfter(newSelectedDate, end) ? truthyResult : {\n      nextSelection: 'end',\n      newRange: [newSelectedDate, end]\n    };\n  }\n  const truthyResult = allowRangeFlip ? {\n    nextSelection: 'end',\n    newRange: [newSelectedDate, start]\n  } : {\n    nextSelection: 'end',\n    newRange: [newSelectedDate, null]\n  };\n  return Boolean(start) && adapter.isBeforeDay(newSelectedDate, start) ? truthyResult : {\n    nextSelection: 'start',\n    newRange: [start, newSelectedDate]\n  };\n}\nexport function calculateRangePreview(options) {\n  if (options.newDate == null) {\n    return [null, null];\n  }\n  const [start, end] = options.range;\n  const {\n    newRange\n  } = calculateRangeChange(options);\n  if (!start || !end) {\n    return newRange;\n  }\n  const [previewStart, previewEnd] = newRange;\n  return options.rangePosition === 'end' ? [end, previewEnd] : [previewStart, start];\n}","map":{"version":3,"names":["mergeDateAndTime","resolveReferenceDate","referenceDate","rangePosition","Array","isArray","calculateRangeChange","adapter","range","newDate","selectedDate","allowRangeFlip","shouldMergeDateAndTime","start","isValid","end","newSelectedDate","truthyResult","nextSelection","newRange","Boolean","isAfter","isBeforeDay","calculateRangePreview","options","previewStart","previewEnd"],"sources":["C:/Users/tamak/Desktop/Workspace/ppe-watcher/node_modules/@mui/x-date-pickers-pro/esm/internals/utils/date-range-manager.js"],"sourcesContent":["import { mergeDateAndTime } from '@mui/x-date-pickers/internals';\nexport function resolveReferenceDate(referenceDate, rangePosition) {\n  if (Array.isArray(referenceDate)) {\n    return rangePosition === 'start' ? referenceDate[0] : referenceDate[1];\n  }\n  return referenceDate;\n}\nexport function calculateRangeChange({\n  adapter,\n  range,\n  newDate: selectedDate,\n  rangePosition,\n  allowRangeFlip = false,\n  shouldMergeDateAndTime = false,\n  referenceDate\n}) {\n  const start = !adapter.isValid(range[0]) ? null : range[0];\n  const end = !adapter.isValid(range[1]) ? null : range[1];\n  if (shouldMergeDateAndTime && selectedDate) {\n    // If there is a date already selected, then we want to keep its time\n    if (start && rangePosition === 'start') {\n      selectedDate = mergeDateAndTime(adapter, selectedDate, start);\n    }\n    if (end && rangePosition === 'end') {\n      selectedDate = mergeDateAndTime(adapter, selectedDate, end);\n    }\n  }\n  const newSelectedDate = referenceDate && selectedDate && shouldMergeDateAndTime ? mergeDateAndTime(adapter, selectedDate, resolveReferenceDate(referenceDate, rangePosition)) : selectedDate;\n  if (rangePosition === 'start') {\n    const truthyResult = allowRangeFlip ? {\n      nextSelection: 'start',\n      newRange: [end, newSelectedDate]\n    } : {\n      nextSelection: 'end',\n      newRange: [newSelectedDate, null]\n    };\n    return Boolean(end) && adapter.isAfter(newSelectedDate, end) ? truthyResult : {\n      nextSelection: 'end',\n      newRange: [newSelectedDate, end]\n    };\n  }\n  const truthyResult = allowRangeFlip ? {\n    nextSelection: 'end',\n    newRange: [newSelectedDate, start]\n  } : {\n    nextSelection: 'end',\n    newRange: [newSelectedDate, null]\n  };\n  return Boolean(start) && adapter.isBeforeDay(newSelectedDate, start) ? truthyResult : {\n    nextSelection: 'start',\n    newRange: [start, newSelectedDate]\n  };\n}\nexport function calculateRangePreview(options) {\n  if (options.newDate == null) {\n    return [null, null];\n  }\n  const [start, end] = options.range;\n  const {\n    newRange\n  } = calculateRangeChange(options);\n  if (!start || !end) {\n    return newRange;\n  }\n  const [previewStart, previewEnd] = newRange;\n  return options.rangePosition === 'end' ? [end, previewEnd] : [previewStart, start];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}